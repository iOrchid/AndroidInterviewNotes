# Java面试题之多线程(三)

标签（空格分隔）： Java面试题 多线程

---

### volatile关键字在Java中有什么作用？
volatile是一个特殊的修饰符，只有成员变量才能使用它。

在Java并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。

volatile变量可以保证下一个读取操作会在前一个写操作之后发生。

### volatile 变量和 atomic 变量有什么不同？
首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。

Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。

而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。

### Java中的同步集合与并发集合有什么区别？
同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。

Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分区等现代技术提高了可扩展性。

### Vector是一个线程安全类吗？
Vector 是用同步方法来实现线程安全的

### ReadWriteLock是什么？
一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。

Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读锁。

### 什么是FutureTask？
在Java并发程序中FutureTask表示一个可以取消的异步运算。

它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。
　　
### 什么是ThreadLocal变量？
ThreadLocal是Java里一种特殊的变量。

每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。它是为创建代价高昂的对象获取线程安全的好方法，比如你可以用ThreadLocal让SimpleDateFormat变成线程安全的，因为那个类创建代价高昂且每次调用都需要创建不同的实例所以不值得在局部范围使用它，如果为每个线程提供一个自己独有的变量拷贝，将大大提高效率。

首先，通过复用减少了代价高昂的对象的创建个数。
其次，你在没有使用高代价的同步或者不变性的情况下获得了线程安全。

线程局部变量的另一个不错的例子是ThreadLocalRandom类，它在多线程环境中减少了创建代价高昂的Random对象的个数。

### 什么是Java线程转储(Thread Dump)，如何得到它？
线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。

有很多方法可以获取线程转储——使用Profiler，Kill-3命令，jstack工具等等。有的更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以可以编写一些脚本去定时的产生线程转储以待分析。

### 如果你提交任务时，线程池队列已满。会时发会生什么？
如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务；

如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。
 
### 线程之间是如何通信的？
当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。

Object类中wait()notify()notifyAll()方法可以用于线程间通信关于资源的锁的状态。

### 怎么检测一个线程是否持有对象监视器
Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候，才会返回true.注意这是一个static方法，这意味着"某条线程"指的是当前线程。


### 什么是死锁(Deadlock)？
死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

### 锁的分类
1、自旋锁
2、自旋锁的其他种类
3、阻塞锁
4、可重入锁
5、读写锁
6、互斥锁
7、悲观锁
8、乐观锁
9、公平锁
10、非公平锁
11、偏向锁
12、对象锁
13、线程锁
14、锁粗化
15、轻量级锁
16、锁消除
17、锁膨胀
18、信号量
### 死锁发生的几个条件是什么

- 因为系统资源不足。
- 进程运行推进的顺序不合适。
- 资源分配不当。

### 实现一个死锁？
产生死锁的四个必要条件：

- 互斥条件：所谓互斥就是进程在某一时间内独占资源。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

### 如何避免死锁？
打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。

1. 打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。
2. 打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。

3. 打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。
四.打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。

###  Java中活锁和死锁有什么区别？
活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。

一个现实的活锁例子是两个人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。

简单的说就是，活锁和死锁的主要区别是前者进程的状态可以改变但是却不能继续执行。

### 死锁与饥饿的区别？ 
饥饿是指系统不能保证某个进程的等待时间上界，从而使该进程长时间等待，当等待时间给进程推进和响应带来明显影响时，称发生了进程饥饿。当饥饿到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被饿死。

死锁是指在多道程序系统中，一组进程中的每一个进程都无限期等待被该组进程中的另一个进程所占有且永远不会释放的资源。

相同点：二者都是由于竞争资源而引起的。

不同点：

- 从进程状态考虑，死锁进程都处于等待状态，忙等待(处于运行或就绪状态)的进程并非处于等待状态，但却可能被饿死；
- 死锁进程等待永远不会被释放的资源，饿死进程等待会被释放但却不会分配给自己的资源，表现为等待时限没有上界(排队等待或忙式等待)；
- 死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死；
- 死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个。
- 在饥饿的情形下，系统中有至少一个进程能正常运行，只是饥饿进程得不到执行机会。而死锁则可能会最终使整个系统陷入死锁并崩溃。

### 什么是乐观锁和悲观锁
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。

### 什么是对象锁？
对象锁是指Java为临界区synchronized(Object)语句指定的对象进行加锁，对象锁是独占排他锁。

对于对象锁，是针对一个对象的，它只在该对象的某个内存位置声明一个标志位标识该对象是否拥有锁，所以它只会锁住当前的对象。一般一个对象锁是对一个非静态成员变量进行syncronized修饰，或者对一个非静态方法进行syncronized修饰。对于对象锁，不同对象访问同一个被syncronized修饰的方法的时候不会阻塞住。
  
### 怎么检测一个线程是否拥有锁？
在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。

### Java中synchronized 和 ReentrantLock 有什么不同？
Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。

### 可重入锁的含义
可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。

在Java环境下 ReentrantLock 和synchronized 都是可重入锁

### 什么是CAS
CAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功

### 结束